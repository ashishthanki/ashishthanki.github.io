{
    "componentChunkName": "component---themes-advanced-src-templates-post-query-ts",
    "path": "/sequences",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Sequences\",\n  \"cover\": \"images/array_vs_list.png\",\n  \"coverAlt\": \"Arrays vs Lists in memory\",\n  \"description\": \"Interesting facts about sequences.\",\n  \"datePublished\": \"2023-01-14\",\n  \"dateModified\": \"2023-02-10\",\n  \"category\": \"Shorts\",\n  \"tags\": [\"Programming\", \"Python\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I recently started to re-learn parts of Python, and wanted to write this \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"category/Shorts\"\n  }, \"shorts\"), \" blog post on a few interesting things I have learnt.\"), mdx(\"h3\", null, \"Lists\"), mdx(\"p\", null, \"Python lists and numpy arrays are both used to store collections of items, but they have some important differences. Every Python object in memory has metadata attached to it. Alongside the header (i.e. the location), Python stores the object's reference count, a pointer to the object's type and a \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"C\"), \" double holding the value.\"), mdx(\"p\", null, \"Lists can perform mathematical operations, but they are not optimized for this task. Numpy arrays, on the other hand, are specifically designed for mathematical operations, and they provide a wide range of built-in functions and methods for performing mathematical operations on arrays. \"), mdx(\"p\", null, \"Meanwhile, an \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"array\"), \" of floats (for example, \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"numpy\"), \" arrays), only stores the value of the contents, and not as a sequence of Python objects. This is why arrays are much more compact and utilises less memory space.\"), mdx(\"p\", null, \"Performing a concatenation, such as \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"a += b\"), \", and depending on the object type, would either perform \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"a.extend(b)\"), \" for mutable object, or \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"a = a + b\"), \" for immutable objects. This sort of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"augmented assignment\"), \" (and others such as \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"*=\"), \" and \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"-=\"), \") is only possible of the objects has an \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"__iadd__\"), \" (\\\"in-place addition\\\") method otherwise Python falls back to \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"__add__\"), \" method.\"), mdx(\"h3\", null, \"Tuples\"), mdx(\"p\", null, \"Repeated \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"augmented assignment\"), \" for immutable sequences (tuples) is inefficient because the items are not appending to the end of the item but a copy of the target sequence is made with the new items concatenated. \"), mdx(\"p\", null, \"Another type of sequence in Python is the tuple. Tuples are similar to lists but they are immutable, meaning that once they are created, you cannot change the items inside them. So try answer the question below where we use augmented assignment. \"), mdx(\"p\", null, \"Question:\"), mdx(\"p\", null, \"What happens when we run the below python code? \"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"python\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-python\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \">>\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \">\"), \" t \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"0\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"1\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"30\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"40\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \">>\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \">\"), \" t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"2\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+=\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"50\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"60\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\")))), mdx(\"p\", null, \"Answers?\"), mdx(\"p\", null, \"A: No issues.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"python\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-python\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \">>\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \">\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"print\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"1\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"2\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"30\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"40\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"50\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"60\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\")))), mdx(\"p\", null, \"B: Type Error\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"python\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-python\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \">>\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \">\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"print\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \"\\nTypeError\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \":\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"'tuple'\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token builtin\"\n  }, \"object\"), \" does \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"not\"), \" support item assignment\"))), mdx(\"p\", null, \"C:. Neither of the above.\"), mdx(\"p\", null, \"D: Both 1 and 2.\"), mdx(\"p\", null, \"The answer is actually both A and B. This occurs because when we access the object within the tuple it is a list which is mutable, however, when we assign this new list to the immutable tuple object Python realises that this is an immutable object, hence, fails. \"), mdx(\"h3\", null, \"Dictionaries\"), mdx(\"p\", null, \"Dictionaries are really interesting. The key value pair object must have keys which are hashable. Implementing \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"__hash__\"), \" and \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"__eq__\"), \" methods. Python has extremely fast access to millions of keys because it directly computes the hash code of the key alongside an index offset to locate the matching entry in a few number of attempts. \"), mdx(\"p\", null, \"Key ordering is now part of Python 3.7 onwards. Dictionaries have significant memory overhead since a hash table needs to be created with Python keeping at least one-third of the row empty to remain efficient. In case you are wondering what the most compact data structure is, it is a tuple. Which is a container with an array of pointers to the items.\"), mdx(\"p\", null, \"When creating an instance attribute, avoid doing so outside of the \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"__init__\"), \" method because another \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"dict\"), \" needs to be created on top of the existing instance - further increasing the memory requirement since hash tables have empty rows.\"), mdx(\"p\", null, \"Creating an instance attribute, with attributes only being created within \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"__init__\"), \", it is stored within a special \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"__dict__\"), \" attribute and is attached to each instance. When multiple instances are created a common hash table is shared by the \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"__dict__\"), \". PEP 412 says that this optimization reduces memory by 10% to 20% for object orientated programs.\"), mdx(\"h3\", null, \"Sets\"), mdx(\"p\", null, \"Sets are amazing.\"), mdx(\"p\", null, \"Sets operations are faster, simpler and offer faster solutions to many tasks. Set classes have an intuitive API design and can be used for many applications. We can use operator overloading to simplify our code to make it shorter and faster. \"), mdx(\"p\", null, \"The methods that sets have prevent unnecessary copies of iterables, and for loops. The set operations and methods either produce a new set or update the target set in place (if it's mutable). \"), mdx(\"p\", null, \"I will continue to add to this blog as more interesting facts come along.\"), mdx(\"h4\", null, \"Further Reading:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Fluent Python book by Luciano Ramalho\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=aumxFs2DO5o&ab_channel=ArjanCodes\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"Deep Dive Into Iterators and Itertools in Python\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=tGAngdU_8D8&ab_channel=PyCon2019\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"Luciano Ramalho - Set Practice: learning from Python's set types PyCon 2019\")))));\n}\n;\nMDXContent.isMDXComponent = true;","timeToRead":3,"excerpt":"I recently started to re-learn parts of Python, and wanted to write this  shorts  blog post on a few interesting things I have learnt. Lists…","frontmatter":{"title":"Sequences","description":"Interesting facts about sequences.","cover":{"publicURL":"/static/2cd573256a0995569f582e2a20c24f07/array_vs_list.png","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABqElEQVQoz22Sa4+qMBCG+f//yBi0IBpvYbNlQQG13YCFovRQ5GK57lnJMVn3vB+adtInM/POSJcoMgzDtu2De0h40j+UpjcIoeO6+POzqqqu6/p/Gu6+769WK8m29+PxWNO0iSw7jjP8CIJgOp1qs5kCAISwrusB67qubdu+7w3DGI1GUhiGQRB+fJhhGBJCMMac8yRJPM+DEB6ORxpFA/xUVVUAgOVyKXHOWRxjjOM4zvOcMUYpzfO8LAqE0J8kybLser0OccaYECKOY1VVFUWR0jS9RJFtO5TSsiy/n5eLEOJ+v9MwzLKsLEtKqWWZ2ny+2+0IIQCA7XarqqpUFIUQd0JIXhRVVfE0pVH0NGY467o+nY66riOEEUKLxWK9XmuaJrVt2zRN13XNozHO+fl8fho7wEIIhE66/oYRnkwm+/3ecRxZlqX+p263W/TI/OIQxkjX38iZKIqy2WxM0wQAvMKc8yAIXoJCiIPrrtcbwzAghFmW+b7/3fPvJHmev6yEEGK3s2Yz7f0dUkrbtrUsaz6fv8L/VdM0jDHP8xhjw8xd1/1b9hdrdF5Ra9pVhAAAAABJRU5ErkJggg=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/2cd573256a0995569f582e2a20c24f07/dd2f0/array_vs_list.png","srcSet":"/static/2cd573256a0995569f582e2a20c24f07/d9b0b/array_vs_list.png 218w,\n/static/2cd573256a0995569f582e2a20c24f07/ba935/array_vs_list.png 436w,\n/static/2cd573256a0995569f582e2a20c24f07/dd2f0/array_vs_list.png 871w","sizes":"(min-width: 871px) 871px, 100vw"},"sources":[{"srcSet":"/static/2cd573256a0995569f582e2a20c24f07/9f643/array_vs_list.avif 218w,\n/static/2cd573256a0995569f582e2a20c24f07/96de2/array_vs_list.avif 436w,\n/static/2cd573256a0995569f582e2a20c24f07/ea7f0/array_vs_list.avif 871w","type":"image/avif","sizes":"(min-width: 871px) 871px, 100vw"},{"srcSet":"/static/2cd573256a0995569f582e2a20c24f07/53cb2/array_vs_list.webp 218w,\n/static/2cd573256a0995569f582e2a20c24f07/6869f/array_vs_list.webp 436w,\n/static/2cd573256a0995569f582e2a20c24f07/beb67/array_vs_list.webp 871w","type":"image/webp","sizes":"(min-width: 871px) 871px, 100vw"}]},"width":871,"height":486.00000000000006}}},"coverAlt":"Arrays vs Lists in memory","datePublished":"2023-01-14","dateModified":"2023-02-10","category":"Shorts","tags":["Programming","Python"]},"fields":{"slug":"/sequences","route":"/sequences","pathName":"/sequences","url":"https://ashishthanki.github.io/sequences"},"internal":{"content":"---\ntitle: \"Sequences\"\ncover: images/array_vs_list.png\ncoverAlt: \"Arrays vs Lists in memory\"\ndescription: \"Interesting facts about sequences.\"\ndatePublished: \"2023-01-14\"\ndateModified: \"2023-02-10\"\ncategory: \"Shorts\"\ntags:\n  - Programming\n  - Python\n---\n\nI recently started to re-learn parts of Python, and wanted to write this [shorts](category/Shorts) blog post on a few interesting things I have learnt.\n\n### Lists\n\nPython lists and numpy arrays are both used to store collections of items, but they have some important differences. Every Python object in memory has metadata attached to it. Alongside the header (i.e. the location), Python stores the object's reference count, a pointer to the object's type and a `C` double holding the value.\n\nLists can perform mathematical operations, but they are not optimized for this task. Numpy arrays, on the other hand, are specifically designed for mathematical operations, and they provide a wide range of built-in functions and methods for performing mathematical operations on arrays. \n\nMeanwhile, an `array` of floats (for example, `numpy` arrays), only stores the value of the contents, and not as a sequence of Python objects. This is why arrays are much more compact and utilises less memory space.\n\nPerforming a concatenation, such as `a += b`, and depending on the object type, would either perform `a.extend(b)` for mutable object, or `a = a + b` for immutable objects. This sort of *augmented assignment* (and others such as `*=` and `-=`) is only possible of the objects has an `__iadd__` (\"in-place addition\") method otherwise Python falls back to `__add__` method.\n\n### Tuples\n\nRepeated *augmented assignment* for immutable sequences (tuples) is inefficient because the items are not appending to the end of the item but a copy of the target sequence is made with the new items concatenated. \n\nAnother type of sequence in Python is the tuple. Tuples are similar to lists but they are immutable, meaning that once they are created, you cannot change the items inside them. So try answer the question below where we use augmented assignment. \n\nQuestion:\n\nWhat happens when we run the below python code? \n\n```python\n>>> t = (0, 1, [30, 40])\n>>> t[2] += [50, 60]\n```\n\nAnswers?\n\nA: No issues.\n\n```python\n>>> print(t)\n(1, 2, [30, 40, 50, 60])\n```\n\nB: Type Error\n\n```python\n>>> print(t)\nTypeError: 'tuple' object does not support item assignment\n```\n\nC:. Neither of the above.\n\nD: Both 1 and 2.\n\nThe answer is actually both A and B. This occurs because when we access the object within the tuple it is a list which is mutable, however, when we assign this new list to the immutable tuple object Python realises that this is an immutable object, hence, fails. \n\n### Dictionaries\n\nDictionaries are really interesting. The key value pair object must have keys which are hashable. Implementing `__hash__` and `__eq__` methods. Python has extremely fast access to millions of keys because it directly computes the hash code of the key alongside an index offset to locate the matching entry in a few number of attempts. \n\nKey ordering is now part of Python 3.7 onwards. Dictionaries have significant memory overhead since a hash table needs to be created with Python keeping at least one-third of the row empty to remain efficient. In case you are wondering what the most compact data structure is, it is a tuple. Which is a container with an array of pointers to the items.\n\nWhen creating an instance attribute, avoid doing so outside of the `__init__` method because another `dict` needs to be created on top of the existing instance - further increasing the memory requirement since hash tables have empty rows.\n\nCreating an instance attribute, with attributes only being created within `__init__`, it is stored within a special `__dict__` attribute and is attached to each instance. When multiple instances are created a common hash table is shared by the `__dict__`. PEP 412 says that this optimization reduces memory by 10% to 20% for object orientated programs.\n\n\n### Sets\n\nSets are amazing.\n\nSets operations are faster, simpler and offer faster solutions to many tasks. Set classes have an intuitive API design and can be used for many applications. We can use operator overloading to simplify our code to make it shorter and faster. \n\nThe methods that sets have prevent unnecessary copies of iterables, and for loops. The set operations and methods either produce a new set or update the target set in place (if it's mutable). \n\nI will continue to add to this blog as more interesting facts come along.\n\n\n#### Further Reading:\n\n\n- Fluent Python book by Luciano Ramalho\n\n- [Deep Dive Into Iterators and Itertools in Python](https://www.youtube.com/watch?v=aumxFs2DO5o&ab_channel=ArjanCodes)\n\n- [Luciano Ramalho - Set Practice: learning from Python's set types PyCon 2019](https://www.youtube.com/watch?v=tGAngdU_8D8&ab_channel=PyCon2019)\n"}}},"pageContext":{"slug":"/sequences","nexttitle":"Architecture Patterns","nextslug":"/architecture-patterns","prevtitle":"SHAP and Synergy","prevslug":"/shap-and-synergy","relatedPosts":[{"title":"Sequences","description":"Interesting facts about sequences.","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABqElEQVQoz22Sa4+qMBCG+f//yBi0IBpvYbNlQQG13YCFovRQ5GK57lnJMVn3vB+adtInM/POSJcoMgzDtu2De0h40j+UpjcIoeO6+POzqqqu6/p/Gu6+769WK8m29+PxWNO0iSw7jjP8CIJgOp1qs5kCAISwrusB67qubdu+7w3DGI1GUhiGQRB+fJhhGBJCMMac8yRJPM+DEB6ORxpFA/xUVVUAgOVyKXHOWRxjjOM4zvOcMUYpzfO8LAqE0J8kybLser0OccaYECKOY1VVFUWR0jS9RJFtO5TSsiy/n5eLEOJ+v9MwzLKsLEtKqWWZ2ny+2+0IIQCA7XarqqpUFIUQd0JIXhRVVfE0pVH0NGY467o+nY66riOEEUKLxWK9XmuaJrVt2zRN13XNozHO+fl8fho7wEIIhE66/oYRnkwm+/3ecRxZlqX+p263W/TI/OIQxkjX38iZKIqy2WxM0wQAvMKc8yAIXoJCiIPrrtcbwzAghFmW+b7/3fPvJHmev6yEEGK3s2Yz7f0dUkrbtrUsaz6fv8L/VdM0jDHP8xhjw8xd1/1b9hdrdF5Ra9pVhAAAAABJRU5ErkJggg=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/2cd573256a0995569f582e2a20c24f07/8fccb/array_vs_list.png","srcSet":"/static/2cd573256a0995569f582e2a20c24f07/a8fd2/array_vs_list.png 165w,\n/static/2cd573256a0995569f582e2a20c24f07/38e56/array_vs_list.png 330w,\n/static/2cd573256a0995569f582e2a20c24f07/8fccb/array_vs_list.png 660w","sizes":"(min-width: 660px) 660px, 100vw"},"sources":[{"srcSet":"/static/2cd573256a0995569f582e2a20c24f07/79731/array_vs_list.avif 165w,\n/static/2cd573256a0995569f582e2a20c24f07/6ae0f/array_vs_list.avif 330w,\n/static/2cd573256a0995569f582e2a20c24f07/a7415/array_vs_list.avif 660w","type":"image/avif","sizes":"(min-width: 660px) 660px, 100vw"},{"srcSet":"/static/2cd573256a0995569f582e2a20c24f07/55a9a/array_vs_list.webp 165w,\n/static/2cd573256a0995569f582e2a20c24f07/39687/array_vs_list.webp 330w,\n/static/2cd573256a0995569f582e2a20c24f07/14a96/array_vs_list.webp 660w","type":"image/webp","sizes":"(min-width: 660px) 660px, 100vw"}]},"width":660,"height":368},"coverImageAlt":"Arrays vs Lists in memory","datePublished":"2023-01-14T00:00:00.000Z","dateModified":"2023-02-10T00:00:00.000Z","category":"Shorts","tags":["Programming","Python"],"excerpt":"I recently started to re-learn parts of Python, and wanted to write this  shorts  blog post on a few interesting things I have learnt. Lists…","timeToRead":3,"slug":"/sequences","route":"/sequences","pathName":"/sequences","url":"https://ashishthanki.github.io/sequences"},{"title":"Stranger Methods","description":"Understanding dunder methods","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAMF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAQD/2gAMAwEAAhADEAAAAdGYUwP/xAAXEAEBAQEAAAAAAAAAAAAAAAAAEQIT/9oACAEBAAEFAqjrp//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAEDAQE/ASf/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAaEAACAgMAAAAAAAAAAAAAAAAAAQIRInHh/9oACAEBAAY/AqR0xg62f//EABkQAAIDAQAAAAAAAAAAAAAAAAERACFBgf/aAAgBAQABPyFEhrNlmSSyKigdBJ//2gAMAwEAAgADAAAAEPf/AP/EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAEDAQE/EAE//8QAFhEBAQEAAAAAAAAAAAAAAAAAARAR/9oACAECAQE/EF2f/8QAGhABAAIDAQAAAAAAAAAAAAAAAQARITFBkf/aAAgBAQABPxCtWQ3cIhEGOxxx4GpTYkWILyf/2Q=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/2b1ae0ceb13d2648e4bbd3fe92ae34f4/d43de/cover_1.jpg","srcSet":"/static/2b1ae0ceb13d2648e4bbd3fe92ae34f4/2ab11/cover_1.jpg 230w,\n/static/2b1ae0ceb13d2648e4bbd3fe92ae34f4/16c5c/cover_1.jpg 460w,\n/static/2b1ae0ceb13d2648e4bbd3fe92ae34f4/d43de/cover_1.jpg 920w,\n/static/2b1ae0ceb13d2648e4bbd3fe92ae34f4/3f865/cover_1.jpg 1840w","sizes":"(min-width: 920px) 920px, 100vw"},"sources":[{"srcSet":"/static/2b1ae0ceb13d2648e4bbd3fe92ae34f4/ee20b/cover_1.avif 230w,\n/static/2b1ae0ceb13d2648e4bbd3fe92ae34f4/5c720/cover_1.avif 460w,\n/static/2b1ae0ceb13d2648e4bbd3fe92ae34f4/991c3/cover_1.avif 920w,\n/static/2b1ae0ceb13d2648e4bbd3fe92ae34f4/b7eae/cover_1.avif 1840w","type":"image/avif","sizes":"(min-width: 920px) 920px, 100vw"},{"srcSet":"/static/2b1ae0ceb13d2648e4bbd3fe92ae34f4/1d6f2/cover_1.webp 230w,\n/static/2b1ae0ceb13d2648e4bbd3fe92ae34f4/f0b6f/cover_1.webp 460w,\n/static/2b1ae0ceb13d2648e4bbd3fe92ae34f4/d54e9/cover_1.webp 920w,\n/static/2b1ae0ceb13d2648e4bbd3fe92ae34f4/382d3/cover_1.webp 1840w","type":"image/webp","sizes":"(min-width: 920px) 920px, 100vw"}]},"width":920,"height":368},"coverImageAlt":"Clear Beach","datePublished":"2022-06-14T00:00:00.000Z","dateModified":"2022-06-14T00:00:00.000Z","category":"Shorts","tags":["Programming","Python"],"excerpt":"The Python  Data Model  has more than 80 special method names. Special methods are symbolised with two underscores on either side of a word…","timeToRead":1,"slug":"/stranger-methods","route":"/stranger-methods","pathName":"stranger-methods","url":"https://ashishthanki.github.io/stranger-methods"}]}},
    "staticQueryHashes": ["3661114550"]}